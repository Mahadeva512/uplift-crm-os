import base64, email
from googleapiclient.discovery import build
from google.oauth2.credentials import Credentials
from fastapi import HTTPException

# ------------------------------------------------------------
# Gmail Client Helper
# ------------------------------------------------------------
class GmailClient:
    def __init__(self, user_email):
        self.user_email = user_email
        token_path = f"tokens/{user_email}.json"
        creds = Credentials.from_authorized_user_file(token_path, ["https://mail.google.com/"])
        self.service = build("gmail", "v1", credentials=creds, cache_discovery=False)

    # --------------------------------------------------------
    # Send or Reply
    # --------------------------------------------------------
    async def send_email(self, to, subject, body, threadId=None, attachments=None):
    import base64, email
    message = email.message.EmailMessage()
    message.set_content(body)
    message["To"], message["Subject"] = to, subject

    # Thread linking (critical)
    if threadId:
        try:
            thread = self.service.users().threads().get(userId="me", id=threadId).execute()
            parent_headers = {h["name"]: h["value"] for h in thread["messages"][0]["payload"]["headers"]}
            parent_mid = parent_headers.get("Message-ID")
            if parent_mid:
                message["In-Reply-To"] = parent_mid
                message["References"] = parent_mid
        except Exception as e:
            print("Warning: could not fetch thread:", e)

    raw = base64.urlsafe_b64encode(message.as_bytes()).decode()
    body_dict = {"raw": raw}
    if threadId:
        body_dict["threadId"] = threadId  # tells Gmail to keep it in the same conversation

    sent = self.service.users().messages().send(userId="me", body=body_dict).execute()
    return {"id": sent.get("id"), "threadId": sent.get("threadId")}

    # --------------------------------------------------------
    # Mark Thread Read / Unread
    # --------------------------------------------------------
    def mark_thread(self, threadId, unread=False):
        try:
            mods = {"addLabelIds": ["UNREAD"]} if unread else {"removeLabelIds": ["UNREAD"]}
            self.service.users().threads().modify(userId="me", id=threadId, body=mods).execute()
            return True
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Mark thread failed: {e}")

    # --------------------------------------------------------
    # Fetch Messages for a Lead
    # --------------------------------------------------------
    def get_messages(self, lead_email):
        try:
            results = self.service.users().messages().list(
                userId="me", q=f"from:{lead_email} OR to:{lead_email}", maxResults=30
            ).execute()
            messages = []
            for m in results.get("messages", []):
                full = self.service.users().messages().get(userId="me", id=m["id"]).execute()
                messages.append(full)
            return messages
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Message fetch error: {e}")
